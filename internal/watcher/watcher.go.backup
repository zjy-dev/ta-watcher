package watcher

import (
	"context"
	"fmt"
	"log"
	"time"

	"ta-watcher/internal/config"
	"ta-watcher/internal/datasource"
	"ta-watcher/internal/	for _, strat := range w.strategies {
		result, err := strat.Evaluate(marketData)
		if err != nil {
			log.Printf("⚠️ %s 策略评估错误: %v", strat.Name(), err)
			continue
		}

		if result != nil {
			// 总是显示策略值，不管是否触发信号
			if rsiValue, exists := result.Indicators["rsi"]; exists {
				if result.ShouldNotify() {
					// 触发信号时用醒目的标记
					log.Printf("🚨 信号: %s/%s (%s) - RSI:%.1f %s (%.1f%%)",
						symbol, timeframe, strat.Name(), rsiValue, result.Signal.String(), result.Confidence*100)
				} else {
					// 未触发信号时也显示RSI值
					log.Printf("📈 %s/%s (%s) - RSI:%.1f %s",
						symbol, timeframe, strat.Name(), rsiValue, result.Signal.String())
				}
			} else {
				// 其他类型的策略
				if result.ShouldNotify() {
					log.Printf("🚨 信号: %s/%s (%s) - %s (%.1f%%)",
						symbol, timeframe, strat.Name(), result.Signal.String(), result.Confidence*100)
				} else {
					log.Printf("📈 %s/%s (%s) - %s",
						symbol, timeframe, strat.Name(), result.Signal.String())
				}
			}
		}
	}her 重构后的监控器
type Watcher struct {
	dataSource datasource.DataSource
	strategies []strategy.Strategy
}

// New 创建新的监控器
func New(cfg *config.Config) (*Watcher, error) {
	factory := datasource.NewFactory()
	ds, err := factory.CreateDataSource("binance", cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to create data source: %w", err)
	}

	strategyFactory := strategy.NewFactory()
	strategies := []strategy.Strategy{}

	rsiStrategy, err := strategyFactory.CreateStrategy("rsi_oversold")
	if err == nil {
		strategies = append(strategies, rsiStrategy)
		log.Printf("✅ Created strategy: %s", rsiStrategy.Name())
	}

	log.Printf("✅ Created data source: %s with %d strategies", ds.Name(), len(strategies))

	return &Watcher{
		dataSource: ds,
		strategies: strategies,
	}, nil
}

// Start 启动监控
func (w *Watcher) Start(ctx context.Context) error {
	symbols := []string{"BTCUSDT", "ETHUSDT"}
	timeframes := []datasource.Timeframe{datasource.Timeframe1h, datasource.Timeframe4h}

	for _, symbol := range symbols {
		for _, tf := range timeframes {
			go w.Watch(ctx, symbol, tf)
		}
	}

	<-ctx.Done()
	return nil
}

// Watch 监控单个交易对
func (w *Watcher) Watch(ctx context.Context, symbol string, timeframe datasource.Timeframe) error {
	log.Printf("🚀 开始监控 %s (%s)", symbol, timeframe)

	maxDataPoints := 50
	for _, strat := range w.strategies {
		if required := strat.RequiredDataPoints(); required > maxDataPoints {
			maxDataPoints = required
		}
	}

	ticker := time.NewTicker(2 * time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			log.Printf("⏹️ 停止监控 %s", symbol)
			return nil
		case <-ticker.C:
			if err := w.analyzeSymbol(ctx, symbol, timeframe, maxDataPoints); err != nil {
				log.Printf("❌ 分析 %s 时出错: %v", symbol, err)
			}
		}
	}
}

// analyzeSymbol 分析交易对
func (w *Watcher) analyzeSymbol(ctx context.Context, symbol string, timeframe datasource.Timeframe, maxDataPoints int) error {
	endTime := time.Now()

	// 根据时间框架计算正确的开始时间
	var duration time.Duration
	switch timeframe {
	case datasource.Timeframe1m:
		duration = time.Duration(maxDataPoints*2) * time.Minute
	case datasource.Timeframe3m:
		duration = time.Duration(maxDataPoints*2) * 3 * time.Minute
	case datasource.Timeframe5m:
		duration = time.Duration(maxDataPoints*2) * 5 * time.Minute
	case datasource.Timeframe15m:
		duration = time.Duration(maxDataPoints*2) * 15 * time.Minute
	case datasource.Timeframe30m:
		duration = time.Duration(maxDataPoints*2) * 30 * time.Minute
	case datasource.Timeframe1h:
		duration = time.Duration(maxDataPoints*2) * time.Hour
	case datasource.Timeframe2h:
		duration = time.Duration(maxDataPoints*2) * 2 * time.Hour
	case datasource.Timeframe4h:
		duration = time.Duration(maxDataPoints*2) * 4 * time.Hour
	case datasource.Timeframe6h:
		duration = time.Duration(maxDataPoints*2) * 6 * time.Hour
	case datasource.Timeframe8h:
		duration = time.Duration(maxDataPoints*2) * 8 * time.Hour
	case datasource.Timeframe12h:
		duration = time.Duration(maxDataPoints*2) * 12 * time.Hour
	case datasource.Timeframe1d:
		duration = time.Duration(maxDataPoints*2) * 24 * time.Hour
	case datasource.Timeframe3d:
		duration = time.Duration(maxDataPoints*2) * 3 * 24 * time.Hour
	case datasource.Timeframe1w:
		duration = time.Duration(maxDataPoints*2) * 7 * 24 * time.Hour
	case datasource.Timeframe1M:
		duration = time.Duration(maxDataPoints*2) * 30 * 24 * time.Hour
	default:
		// 默认按小时计算
		duration = time.Duration(maxDataPoints*2) * time.Hour
	}

	startTime := endTime.Add(-duration)

	klines, err := w.dataSource.GetKlines(ctx, symbol, timeframe, startTime, endTime, maxDataPoints*2)
	if err != nil {
		return fmt.Errorf("获取K线数据失败: %w", err)
	}

	if len(klines) < maxDataPoints {
		return fmt.Errorf("数据点不足: 需要 %d，实际 %d", maxDataPoints, len(klines))
	}

	marketData := &strategy.MarketData{
		Symbol:    symbol,
		Timeframe: timeframe,
		Klines:    klines,
		Timestamp: time.Now(),
	}

	for _, strat := range w.strategies {
		result, err := strat.Evaluate(marketData)
		if err != nil {
			log.Printf("⚠️ %s 策略评估错误: %v", strat.Name(), err)
			continue
		}

		if result != nil {
			if result.ShouldNotify() {
				// 只输出触发的信号
				if rsiValue, exists := result.Indicators["rsi"]; exists {
					log.Printf("� 信号: %s/%s (%s) - RSI:%.1f %s (%.1f%%)",
						symbol, timeframe, strat.Name(), rsiValue, result.Signal.String(), result.Confidence*100)
				} else {
					log.Printf("🚨 信号: %s/%s (%s) - %s (%.1f%%)",
						symbol, timeframe, strat.Name(), result.Signal.String(), result.Confidence*100)
				}
			}
		}
	}

	return nil
}

// RunSingleCheck 执行单次检查所有交易对
func (w *Watcher) RunSingleCheck(ctx context.Context, symbols []string, timeframes []datasource.Timeframe) error {
	log.Printf("🔍 开始单次检查 - %d 个交易对，%d 个时间框架", len(symbols), len(timeframes))

	// 计算所有策略需要的最大数据点数
	maxDataPoints := 0
	for _, strat := range w.strategies {
		required := strat.RequiredDataPoints()
		if required > maxDataPoints {
			maxDataPoints = required
		}
	}

	// 设置合理的最小值
	if maxDataPoints < 20 {
		maxDataPoints = 20
	}

	checkCount := 0
	for _, symbol := range symbols {
		for _, tf := range timeframes {
			log.Printf("📊 分析 %s (%s)...", symbol, tf)
			if err := w.analyzeSymbol(ctx, symbol, tf, maxDataPoints); err != nil {
				log.Printf("❌ %s (%s): %v", symbol, tf, err)
				continue
			}
			log.Printf("✅ %s (%s) 完成", symbol, tf)
			checkCount++
		}
	}

	log.Printf("✅ 单次检查完成 - 成功检查了 %d 个组合", checkCount)
	return nil
}

// Stop 停止监控 (兼容接口)
func (w *Watcher) Stop() {}

// IsRunning 检查运行状态 (兼容接口)
func (w *Watcher) IsRunning() bool {
	return true
}

// GetStatus 获取状态 (兼容接口)
func (w *Watcher) GetStatus() map[string]interface{} {
	return map[string]interface{}{
		"running":     true,
		"data_source": w.dataSource.Name(),
		"strategies":  len(w.strategies),
	}
}
